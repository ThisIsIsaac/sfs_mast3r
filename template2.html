<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>3D Reconstruction Results Viewer</title>
    <script type="importmap">
    {
      "imports": {
        "three": "https://unpkg.com/three@0.159.0/build/three.module.js",
        "three/addons/": "https://unpkg.com/three@0.159.0/examples/jsm/"
      }
    }
    </script>
    <style>
        body { margin: 0; padding: 0; font-family: Arial, sans-serif; }
        #results-container { display: flex; flex-wrap: wrap; justify-content: space-around; }
        .result-item { 
            width: 100%; 
            max-width: 600px; 
            margin: 10px; 
            padding: 10px; 
            border: 1px solid #ccc; 
            box-sizing: border-box;
        }
        .input-images { 
            display: flex; 
            justify-content: space-between; 
            height: 200px; 
            gap: 10px;
            margin-bottom: 10px;
        }
        .image-container {
            width: 48%;
            height: 100%;
            overflow: hidden;
            position: relative;
        }
        .image-container img { 
            width: 100%;
            height: 100%;
            object-fit: cover;
            position: absolute;
            top: 0;
            left: 0;
        }
        .reconstruction-view { 
            width: 100%; 
            height: 300px; 
            position: relative;
        }
        #controls { 
            position: fixed; 
            top: 10px; 
            left: 10px; 
            background: rgba(255,255,255,0.8); 
            padding: 10px; 
            border-radius: 5px; 
            z-index: 1000;
        }
        #score-filter { margin-top: 10px; }
        #pagination { display: flex; justify-content: center; margin-top: 20px; }
        #pagination button { margin: 0 5px; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="items-per-page">Items per page:</label>
        <input type="number" id="items-per-page" min="1" max="100" value="20">
        <div id="score-filter">
            <label for="min-score">Min Score:</label>
            <input type="number" id="min-score" step="0.01" value="0">
            <label for="max-score">Max Score:</label>
            <input type="number" id="max-score" step="0.01" value="1">
            <button id="apply-filter">Apply Filter</button>
        </div>
    </div>
    <div id="results-container"></div>
    <div id="pagination">
        <button id="prev-page">&lt; Previous</button>
        <span id="page-info"></span>
        <button id="next-page">Next &gt;</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    
        // Mock data - replace this with your actual data loading mechanism
        const mockData = Array.from({ length: 1000 }, (_, i) => ({}));
    
        let currentPage = 1;
        let itemsPerPage = 20;
        let filteredData = [...mockData];
    
        const resultsContainer = document.getElementById('results-container');
        const itemsPerPageInput = document.getElementById('items-per-page');
        const minScoreInput = document.getElementById('min-score');
        const maxScoreInput = document.getElementById('max-score');
        const applyFilterButton = document.getElementById('apply-filter');
        const prevPageButton = document.getElementById('prev-page');
        const nextPageButton = document.getElementById('next-page');
        const pageInfo = document.getElementById('page-info');
    
        // Maps to keep track of renderers and observers
        const reconstructionRenderers = new Map(); // Map from item.id to renderer data
        const itemsMap = {}; // Map from item.id to item data
    
        function createResultItem(item) {
            const resultItem = document.createElement('div');
            resultItem.className = 'result-item';
            resultItem.innerHTML = `
                <div class="input-images">
                    <div class="image-container">
                        <img src="${item.inputImage1}" alt="Input 1">
                    </div>
                    <div class="image-container">
                        <img src="${item.inputImage2}" alt="Input 2">
                    </div>
                </div>
                <div class="reconstruction-view" id="reconstruction-${item.id}" data-id="${item.id}"></div>
                <p>Score: ${item.score.toFixed(2)}</p>
            `;
            return resultItem;
        }
    
        function loadResults() {
            resultsContainer.innerHTML = '';
            const startIndex = (currentPage - 1) * itemsPerPage;
            const endIndex = startIndex + itemsPerPage;
            const pageItems = filteredData.slice(startIndex, endIndex);
    
            // Update itemsMap
            pageItems.forEach(item => {
                itemsMap[item.id] = item;
            });
    
            pageItems.forEach(item => {
                const resultItem = createResultItem(item);
                resultsContainer.appendChild(resultItem);
    
                // Observe the reconstruction view for visibility
                const reconstructionElement = resultItem.querySelector('.reconstruction-view');
                observer.observe(reconstructionElement);
            });
    
            updatePagination();
        }
    
        function updatePagination() {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            pageInfo.textContent = `Page ${currentPage} of ${totalPages}`;
            prevPageButton.disabled = currentPage === 1;
            nextPageButton.disabled = currentPage === totalPages;
        }
    
        function initializeReconstruction(id, glbFile) {
            const container = document.getElementById(`reconstruction-${id}`);
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(container.clientWidth, container.clientHeight);
            container.appendChild(renderer.domElement);
    
            const controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.25;
            controls.enableZoom = true;
    
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(1, 1, 1).normalize();
            scene.add(light);
    
            const ambientLight = new THREE.AmbientLight(0x404040);
            scene.add(ambientLight);
    
            const loader = new GLTFLoader();
            let animationFrameId;
            loader.load(glbFile, (gltf) => {
                scene.add(gltf.scene);
    
                // Compute the bounding box of the model
                const box = new THREE.Box3().setFromObject(gltf.scene);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
    
                // Center the model
                gltf.scene.position.sub(center);
    
                // Adjust camera position to fit the model
                const fov = camera.fov * (Math.PI / 180);
                let cameraZ = maxDim / (2 * Math.tan(fov / 2));
    
                cameraZ *= 1.5; // Adjust as needed to add some padding
    
                camera.position.set(0, 0, cameraZ);
                camera.lookAt(new THREE.Vector3(0, 0, 0));
    
                // Update controls
                controls.target.set(0, 0, 0);
                controls.update();
    
                function animate() {
                    animationFrameId = requestAnimationFrame(animate);
                    controls.update();
                    renderer.render(scene, camera);
                }
                animate();
            }, undefined, (error) => {
                console.error('An error occurred while loading the GLB file:', error);
            });
    
            const resizeObserver = new ResizeObserver(() => {
                camera.aspect = container.clientWidth / container.clientHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(container.clientWidth, container.clientHeight);
            });
            resizeObserver.observe(container);
    
            // Store references for disposal later
            reconstructionRenderers.set(id, {
                renderer,
                scene,
                camera,
                controls,
                resizeObserver,
                animationFrameId,
                container
            });
        }
    
        function disposeReconstruction(id) {
            const rendererData = reconstructionRenderers.get(id);
            if (rendererData) {
                const { renderer, scene, controls, resizeObserver, animationFrameId, container } = rendererData;
    
                // Cancel the animation frame
                cancelAnimationFrame(animationFrameId);
    
                // Dispose of the controls
                controls.dispose();
    
                // Dispose of the scene
                scene.traverse(function (object) {
                    if (!object.isMesh) return;
    
                    object.geometry.dispose();
    
                    if (object.material.isMaterial) {
                        cleanMaterial(object.material);
                    } else {
                        // an array of materials
                        for (const material of object.material) cleanMaterial(material);
                    }
                });
    
                function cleanMaterial(material) {
                    material.dispose();
    
                    // dispose textures
                    for (const key in material) {
                        const value = material[key];
                        if (value && typeof value === 'object' && 'minFilter' in value) {
                            value.dispose();
                        }
                    }
                }
    
                // Dispose of the renderer
                renderer.dispose();
    
                // Disconnect the resize observer
                resizeObserver.disconnect();
    
                // Remove the renderer's DOM element
                container.removeChild(renderer.domElement);
    
                // Remove from the map
                reconstructionRenderers.delete(id);
            }
        }
    
        // Intersection Observer to detect visibility
        const observerOptions = {
            root: null,
            rootMargin: '0px',
            threshold: 0.1 // Adjust as needed
        };
    
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                const id = entry.target.dataset.id;
                if (entry.isIntersecting) {
                    // Element is visible, initialize renderer if not already initialized
                    if (!reconstructionRenderers.has(id)) {
                        initializeReconstruction(id, itemsMap[id].reconstructionFile);
                    }
                } else {
                    // Element is not visible, dispose of renderer if exists
                    if (reconstructionRenderers.has(id)) {
                        disposeReconstruction(id);
                    }
                }
            });
        }, observerOptions);
    
        itemsPerPageInput.addEventListener('change', () => {
            itemsPerPage = parseInt(itemsPerPageInput.value);
            currentPage = 1;
            loadResults();
        });
    
        applyFilterButton.addEventListener('click', () => {
            const minScore = parseFloat(minScoreInput.value);
            const maxScore = parseFloat(maxScoreInput.value);
            filteredData = mockData.filter(item => item.score >= minScore && item.score <= maxScore);
            currentPage = 1;
            loadResults();
        });
    
        prevPageButton.addEventListener('click', () => {
            if (currentPage > 1) {
                currentPage--;
                loadResults();
            }
        });
    
        nextPageButton.addEventListener('click', () => {
            const totalPages = Math.ceil(filteredData.length / itemsPerPage);
            if (currentPage < totalPages) {
                currentPage++;
                loadResults();
            }
        });
    
        // Initial load
        loadResults();
    </script>

</body>
</html>